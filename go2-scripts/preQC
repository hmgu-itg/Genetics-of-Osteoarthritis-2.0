#!/usr/bin/env Rscript 
suppressPackageStartupMessages(library("argparse"))
suppressPackageStartupMessages(library("data.table"))
suppressPackageStartupMessages(library(stringr))
suppressPackageStartupMessages(library(gplots))
suppressPackageStartupMessages(library(R.utils))


## PREFLIGHT - Getting Script path
getThisScriptPath <- function() {
        cmdArgs <- commandArgs(trailingOnly = FALSE)
        needle <- "--file="
        match <- grep(needle, cmdArgs)
        if (length(match) > 0) {
                # Rscript
                return(normalizePath(sub(needle, "", cmdArgs[match])))
        } else {
                # 'source'd via R console
                return(normalizePath(sys.frames()[[1]]$ofile))
        }
}
SCRIPT_PATH=getThisScriptPath()
SCRIPT_DIR=dirname(SCRIPT_PATH)
cat(paste("Running from", SCRIPT_DIR, "\n"))

chromLengths=fread(paste(SCRIPT_DIR, "chrom.lengths", sep="/"), header=T)

## PREFLIGHT - Sourcing functions
source(paste(SCRIPT_DIR, "lib/preQC_functions.R", sep="/"))

# create parser object
parser <- ArgumentParser()


# create parser object
parser <- ArgumentParser(description="Prepares summary statistics for EasyQC after filename checking.")

# specify our desired options
# output_covar_file="~/test.covar.file"
# output_pheno_file="~/test.pheno.file"
parser$add_argument("-f", "--infile", required=T,
    help="(required) A comma-separated file as generated by filename_checker.py. Header must contain: PATH,STUDY,PHENO,ETHNICITY,NCASES,NCONTROLS,SOFTWARE,PANEL,BUILD,DATE,ANALYST,GC,FF,ISERROR.")
parser$add_argument("-o", "--outdir", required=F, default=getwd(),
        help="Directory in which to generate the processed summary stats for EasyQC.")
parser$add_argument("-i", "--line", type="integer",
    help="Process only the i-th line of --infile. Useful for parallelisation. Beware that this is done AFTER --strict is applied.")
parser$add_argument("-x", "--strict", action="store_true", default=FALSE,
        help="Enable strict mode. An error will be thrown if there are errors in --infile. An error will be thrown if a file without OR was analysed in a software not specified in --linear.")
parser$add_argument("-d", "--header-file", required=T,
        help="(required) A file containing header fixing information. Should be headerless, tab-separated, with 2 columns. The first column contains the column names you want in your final file. For each such name, the second column is a list of comma-separated fixed strings or patterns. The script will look for these patterns in column names and rename them in the output file.")
parser$add_argument("-l", "--linear",
        help="A file containing a newline-separated list of software for which to apply a fudge factor if it hasn't been already. If this option is not specified, the script will apply fudging for any file that only contains betas, without OR.")

# get command line options, if help option encountered print help and exit,
# otherwise if options not found on command line then set defaults,
if(length(commandArgs(T))==0){
  parser$print_help()
}

args <- parser$parse_args()


## Create directory
OUTDIR=(args$outdir)
if(file.exists(OUTDIR)){
  if(dir.exists(OUTDIR)) {
    inform("The specified output directory", args$outdir, "exists, outputs will be overwritten.")
  }else error("The specified output directory", args$outdir, "exists and is a file.")
} else{
  inform("Creating output directory", args$outdir)
  dir.create(args$outdir)
}
OUTDIR=normalizePath(OUTDIR)

## Read in the files
if(!file.exists(args$infile)){
  error("File", args$infile, "does not exist.")
}

if(!file.exists(args$header_file)){
  error("File", args$header_file, "does not exist.")
}
outFilenameCheckerFn=args$infile
outFilenameChecker=readFnCheckerOutput(outFilenameCheckerFn)
outFilenameChecker=discardFilenameError(outFilenameChecker, strict=args$strict)
#maptbl=fread(args$header_file, skip="#", header=F)
maptbl=tryCatch({fread(args$header_file, skip="#", header=F)}, error=function(cond){fread(args$header_file, header=F)})

## Subset to line if necessary
if(!is.null(args$line)){
  if(args$line>nrow(outFilenameChecker)) error("The specified line number", args$line, "is too large (only", nrow(outFilenameChecker), "rows present)")
  outFilenameChecker=outFilenameChecker[args$line]
  inform("Only processing", outFilenameChecker$PATH, "since --line is set.")
}

## extract software list
softwareList=NULL
if(!is.null(args$linear)){
  if(file.access(args$linear, 4)<0) error("File", args$linear, "is not accessible.")
  softwareList=fread(args$linear, header=F)$V1
  inform("The following software should be treated as QT:", paste(softwareList, collapse=","))
}

for( sumStatsIndex in 1:nrow(outFilenameChecker) ){
    sumStatsInfo=outFilenameChecker[sumStatsIndex]
    sumStatsPath=sumStatsInfo$PATH
    sumStatsBuild=tryCatch({as.numeric(sumStatsInfo$BUILD)}, error=function(e){error("Invalid build", sumStatsInfo$BUILD, "specified for", sumStatsInfo$PATH)})
    inform("File is in build", sumStatsBuild)
    buildIndex=colnames(chromLengths)[colnames(chromLengths)==as.numeric(sumStatsBuild)]
    chromLengthsBuild=unlist(chromLengths[,..buildIndex])
    sumStatsDF=checkHeader(sumStatsPath, maptbl)
    checkColnamesBeforeORConversion(sumStatsDF)
    sumStatsDF=checkOrFillEAF(sumStatsDF, sumStatsInfo)
    sumStatsDF=fixChrCol(sumStatsDF)
    checkChrCol(sumStatsDF)
    sumStatsDF=addCCinDF(sumStatsDF, sumStatsInfo)
    sumStatsDF=checkAndConvertORtoBeta(sumStatsDF, sumStatsInfo, softwareList, args$strict)
    checkAbnormalBetas(sumStatsDF)
    sumStatsDF=createAlphabeticCPTID(sumStatsDF)
    setorder(sumStatsDF, CHRNUM, POS)
    pdfPath=paste(OUTDIR, paste(tools::file_path_sans_ext(basename(sumStatsPath)), "pdf", sep="."), sep="/")
    createDiagnosticsPlots(sumStatsDF, pdfPath, sumStatsBuild, chromLengthsBuild)
    inform(pdfPath, "has been generated.")
    outPath=paste(tools::file_path_sans_ext(basename(sumStatsPath)), "formatted.gz", sep=".")
    fwrite(sumStatsDF[,c("CPTID", "CHR", "POS", "EA", "NEA", "EAF", "P", "BETA", "SE","INFO", "NCASES", "NCONTROLS", "N")],
          paste(OUTDIR, outPath, sep="/"),
          sep="\t", quote=F)
    inform("File", outPath, "has been processed.", '\n')
}
